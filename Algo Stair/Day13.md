# 算法天梯：Day 13
这个题，我是真的很烦啊，爆肝了一整天，巨恶心  
连续学习最长时间，其实就是某段时间内认真学习天数的2倍大于某段时间  
那我们假设从第一天到第i天认真学习天数为i0，到第j天为j0，(i\ltj)那么只要2\*(j0\-i0)\ltj\-i就说明第i\+1天到第j天是认真学习的  
也就是2\*j0\-j\lt2\*i0\-i，那我们开一个数组里面就存2\*i0\-i即可  
但是实践发现这样效率不行，这样遍历去比较会超时，那么就用空间换时间  
再开一个新的数组，下标k对应的内容是满足2\*i0\-i\ltk\-n的最小的i，因为最小的天数对应最长的时间  
我们只需要把每一个第i天的值加上n当作下标得到一个天数，用i和那个天数作差就能得到结果了  
然后把最大的那个结果输出就行了  
上代码
```c++
#include<iostream>
int main(){
    int n,cnt_s=0,temp,max=0;
    scanf("%d",&n);
    int v[n+1];
    int t[2*n+1];
    v[0]=0;//这里虚构了一个第0天，因为如果从第一天开始到第i天的话需要的应该是第0天的值，显然应该是0
    //将后半部分置为0是因为k>n时k-n>0即第0天的值，不会有比第0天更小的天数了
    for(int i=0;i<=n;++i){
        t[i]=-1;
        t[n+i]=0;
    }
    for(int i=1;i<n+1;++i){
        std::cin>>temp;
        if(temp>8){
            ++cnt_s;
        }
        v[i]=2*cnt_s-i;
        //这里因为天数是从小到大的，正好符合我们说的那个最小的天数，没赋值的赋值，赋值了的不用改（因为赋值过的天数一定更小
        for(int j=2*cnt_s-i+n+1;j<=2*n&&t[j]==-1;++j){
            t[j]=i;
        }
    }
    for(int i=1;i<n+1;++i){
        //找到最大的差值就行了
        if(t[v[i]+n]!=-1&&i-t[v[i]+n]>max){
            max=i-t[v[i]+n];
        }
    }
    std::cout<<max;
    return 0;
}
```
这个方法从代码上看很像o(n^2)但实际上应该是o(n)的
注：感谢czg大佬对最后一步的提醒