# 第十周脑力风暴答案

## 一道不那么难的微积分

## 第 k 个排列

### 简单难度

这个是标准库里面有的东西，我又有什么好说的呢。。。  
C 选手请无视我的话。  
简单来说，假设有一个数组 $A$，我们需要从末尾开始找出最长的递减子序列 $A_i,\cdots,A_j$，然后把其中大于 $A_{i-1}$ 的最小的数与 $A_{i-1}$ 交换顺序，然后把新的 $A_i,\cdots,A_j$ 从小到大排列就得到了一个排列的下一个排列。  
重复 $n$ 次就行了。

### 困难难度

我们可以这样来考虑问题：  
求 $A_1,\cdots,A_n$ 这 $n$ 个数的第 $k$ 个排列，可以先找出第一个数 $A_i$，然后求剩下 $n-1$ 个数的第 $m$ 个排列，使得他们排列的顺序刚好和直接求第 $k$ 个排列的顺序相同。

我们知道 $n$ 个数的全排列有 $n!$ 个，而对于每一个数，它放在第一个位置后剩下的数都会有 $(n-1)!$ 个排列，并且第一个数更小的排列一定先于第一个数更大的排列。  
于是，上面的 $A_i$ 其实就是这 $n$ 个数中第 $\lceil\frac k {(n-1)!}\rceil$ 大的数（注意需要向上取整），而 $m=k-(\lceil\frac k {(n-1)!}\rceil-1) \times (n-1)!$。

所以，我们可以递归地按照上面的公式找出每一个位置的数，最后就得到了答案。

需要注意的是找出第 $A_i$ 的过程。你可以先把数组 $A$ 先快速排序一次，然后去 $A_i$，这样做的话整个程序的时间复杂度是 $O(n^2\log n)$，但如果你不排序整个数组，而是只使用快速排序中的划分操作来找出 $A_i$ 的话时间复杂度会是 $O(n^2)$。至于为什么少了那个 $\log n$ 就很难解释了。。。  
思路如下：  
先把数组按照快排那样划分成 $A_1,\cdots,A_{j-1}$、$A_j$ 和 $A_{j+1},\cdots,A_n$，然后，如果 $j<i$，则对后一半再次划分；如果 $j=i$，此时 $A_j$ 就是要找的元素；如果 $j>i$，那么对前一半划分。这样递归下去，直到找到 $A_i$。  
显然一次划分之后前半部分的元素都小于 $A_j$，后半部分都大于等于 $A_j$。那么如果 $j=i$ 就找到了需要的 $A_i$。

具体实现见代码。
