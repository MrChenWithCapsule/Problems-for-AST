<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>算法天梯解析</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <h1 id="算法天梯解析">算法天梯解析</h1>
<p>筒子们是否觉得算法天梯很难呢？<br>
（dlA：我每天早上 8 点就把这一天的题 A 了。<br>
（rubbishB：我就是那个排名在最前面的 Rubbish。<br>
（caijiC：我从第二天开始就不会做。。。</p>
<p>无论你是因为什么原因不会做，相信看完这些题解之后都会大有收获！</p>
<p>那么我们开始吧！</p>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%A4%A9%E6%A2%AF%E8%A7%A3%E6%9E%90">算法天梯解析</a>
<ul>
<li><a href="#day-1">Day 1</a></li>
<li><a href="#day-2">Day 2</a></li>
<li><a href="#day-3">Day 3</a></li>
<li><a href="#day-4">Day 4</a></li>
<li><a href="#day-5">Day 5</a></li>
<li><a href="#day-6">Day 6</a></li>
<li><a href="#day-7">Day 7</a></li>
<li><a href="#day-8">Day 8</a></li>
<li><a href="#day-9">Day 9</a></li>
<li><a href="#day-10">Day 10</a></li>
<li><a href="#day-11">Day 11</a></li>
<li><a href="#day-12">Day 12</a></li>
<li><a href="#day-13">Day 13</a></li>
<li><a href="#day-14">Day 14</a></li>
<li><a href="#day-15">Day 15</a></li>
<li><a href="#day-16">Day 16</a></li>
<li><a href="#day-17">Day 17</a></li>
<li><a href="#day-18">Day 18</a></li>
<li><a href="#day-19">Day 19</a></li>
<li><a href="#day-20">Day 20</a></li>
</ul>
</li>
</ul>
<h2 id="day-1">Day 1</h2>
<p>我们的目的就是排序，常见的排序方法有快速排序，归并排序等<br>
这里说一下快速排序，方法其实很简单<br>
1、找一个 key 值（一般为第一个元素），经过合适的移动将所有比 key 值小的值放到数组左边，大的放右边<br>
2、对两边分别进行快速排序<br>
可以明显地看出这是递归的方式<br>
C/C++代码如下</p>
<pre><code class="language-c++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> e)</span></span>{<span class="hljs-comment">//a为待排序数组，b=begin，e=end</span>
    <span class="hljs-keyword">int</span> i=b,j=e;
    <span class="hljs-keyword">int</span> k=a[b];<span class="hljs-comment">//k就是key值</span>
    <span class="hljs-keyword">if</span>(b&gt;=e)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">while</span>(i&lt;j){

        <span class="hljs-keyword">while</span>(a[i]&lt;k&amp;&amp;i&lt;e){<span class="hljs-comment">//从前往后找到第一个不小于key值的（第一次一定是第一个）</span>
            i++;
        }
        <span class="hljs-keyword">while</span>(a[j]&gt;=k&amp;&amp;j&gt;b){<span class="hljs-comment">//从后往前找第一个小于key值的</span>
            j--;
        }
        <span class="hljs-keyword">if</span>(i&lt;j){<span class="hljs-comment">//只要i比j小说明这两个是逆序，应该互换</span>
            <span class="hljs-keyword">int</span> temp=a[i];
            a[i]=a[j];
            a[j]=temp;
        }
    }
    sort(a,b,j);<span class="hljs-comment">//对前面快排</span>
    sort(a,j+<span class="hljs-number">1</span>,e);<span class="hljs-comment">//对后面快排</span>
    <span class="hljs-keyword">return</span>;
}
</div></code></pre>
<p>注：1、该方法平均复杂度为 o(nlogn)，最坏复杂度为 o(n^2),常用的冒泡排序等复杂度为 o(n^2)<br>
2、因为本渣渣是用 c++写的，所以只能提供 C++的版本<br>
3、对于某些没有使用 vector 的代码可以很容易地转成同学们熟悉的 C，有些不容易转，请多包涵（所有%3==1 的都是我的）</p>
<h2 id="day-2">Day 2</h2>
<p>（水题 😁<br>
这题我们把 1000 以内的整数一个一个遍历一遍就好了，然后每个整数进行检验，如果满足条件就输出。<br>
至于具体的检验方法，我们可以把这个数分解成个位、十位和百位，然后对 0~9 的每个数字设置一个标志，当这个数字出现的时候就把标志置为一。如果某一个标志已经被置为一了说明对应的数字已经出现了两次，那么这个数就不满足要求。</p>
<p>具体代码见下：</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span>
</span>{
    <span class="hljs-keyword">bool</span> used[<span class="hljs-number">10</span>] = {<span class="hljs-literal">false</span>};    <span class="hljs-comment">// 标志</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i)
    {
        <span class="hljs-keyword">int</span> n = num * i;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j) <span class="hljs-comment">// 依次检查个位、十位和百位</span>
        {
            <span class="hljs-keyword">int</span> m = n % <span class="hljs-number">10</span>;
            <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || used[m])  <span class="hljs-comment">// 0 不允许出现在数字中</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            used[m] = <span class="hljs-literal">true</span>;
            n /= <span class="hljs-number">10</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">123</span>; i &lt; <span class="hljs-number">333</span>; ++i)
        <span class="hljs-keyword">if</span> (check(i))   <span class="hljs-comment">// 检查这个数是否符合要求</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; i * <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; i * <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="day-3">Day 3</h2>
<p>提示正解：<a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环问题</a>。</p>
<p>当然，事实上不用管这是什么问题--如果用数组，需要解决的是数组到了头怎么继续循环，即一个判断；如果用链表，那么用循环链表也可以很方便解决。</p>
<p>解决了框架，细节就是怎么把已经被抛弃的学生踢出去，注意顺序。</p>
<p>下面是一个 caiji 的代码(大家尽情骂他吧)。</p>
<pre><code class="language-c"><div>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;len, &amp;k, &amp;m);
  <span class="hljs-keyword">int</span> store[len];<span class="hljs-comment">// 存储编号</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
    store[i] = i + <span class="hljs-number">1</span>;
  }
  <span class="hljs-keyword">int</span> currentk = <span class="hljs-number">0</span>, currentm = len - <span class="hljs-number">1</span>, count = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// currentk指以k为单位的循环指向哪个学生，currentm类似</span>
  <span class="hljs-comment">// count指已经踢掉多少个学生</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (count == len) {
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">int</span> countk = <span class="hljs-number">1</span>, countm = <span class="hljs-number">1</span>;
    <span class="hljs-comment">// countk指本次循环已经数了多少个同学</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">if</span> (countk == k) {<span class="hljs-comment">// 数了k个</span>
        <span class="hljs-keyword">if</span> (store[currentk] &lt; <span class="hljs-number">0</span>) {<span class="hljs-comment">// 指向的学生是已经被踢掉的</span>
          <span class="hljs-keyword">if</span> (currentk == len - <span class="hljs-number">1</span>) {
            currentk = <span class="hljs-number">0</span>;
          } <span class="hljs-keyword">else</span> {
            currentk++;
          }
          <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 继续循环</span>
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 找到本次循环目标</span>
        }
      }
      <span class="hljs-keyword">if</span> (store[currentk] &gt; <span class="hljs-number">0</span>) {<span class="hljs-comment">// 指向的学生未被踢出</span>
        countk++;
      }
      <span class="hljs-keyword">if</span> (currentk == len - <span class="hljs-number">1</span>) {<span class="hljs-comment">// 数组到头了</span>
        currentk = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> {
        currentk++;
      }
    }
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<span class="hljs-comment">// 和上面循环类似</span>
      <span class="hljs-keyword">if</span> (countm == m) {
        <span class="hljs-keyword">if</span> (store[currentm] &lt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">if</span> (currentm == <span class="hljs-number">0</span>) {
            currentm = len - <span class="hljs-number">1</span>;
          } <span class="hljs-keyword">else</span> {
            currentm--;
          }
          <span class="hljs-keyword">continue</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">if</span> (store[currentm] &gt; <span class="hljs-number">0</span>) {
        countm++;
      }
      <span class="hljs-keyword">if</span> (currentm == <span class="hljs-number">0</span>) {
        currentm = len - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        currentm--;
      }
    }
    <span class="hljs-keyword">if</span> (currentk == currentm) {<span class="hljs-comment">// 找到班长了</span>
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, store[currentk]);
      <span class="hljs-keyword">break</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d"</span>, store[currentk], store[currentm]);
      store[currentk] = -store[currentk];
      store[currentm] = -store[currentm];<span class="hljs-comment">// 踢人</span>
      count = count + <span class="hljs-number">2</span>;<span class="hljs-comment">// 踢了俩</span>
      <span class="hljs-keyword">if</span> (count != len) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);
      }
      <span class="hljs-keyword">if</span> (currentk == len - <span class="hljs-number">1</span>) {
        currentk = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> {
        currentk++;
      }
      <span class="hljs-keyword">if</span> (currentm == <span class="hljs-number">0</span>) {
        currentm = len - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        currentm--;
      }
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="day-4">Day 4</h2>
<p>关于这题，题目的提示其实已经很明显了，就是只计次数，用一个 10001 大小的数组存一下每个数字出现了几次就好了<br>
话不多说上代码</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">int</span> t1[<span class="hljs-number">10001</span>]={<span class="hljs-number">0</span>};<span class="hljs-comment">//记录餐厅1和2的和</span>
<span class="hljs-keyword">int</span> t2[<span class="hljs-number">10001</span>]={<span class="hljs-number">0</span>};<span class="hljs-comment">//记录餐厅3和4的和</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;n;
    <span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>][n];
    <span class="hljs-comment">//输入，不做解释</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j){
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;a[i][j];
        }
    }
    <span class="hljs-comment">//通过两个循环把所有两个餐厅的和记录下来</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j){
            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>][i]+a[<span class="hljs-number">1</span>][j]&lt;=<span class="hljs-number">10000</span>){
                ++t1[a[<span class="hljs-number">0</span>][i]+a[<span class="hljs-number">1</span>][j]];
            }
            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">2</span>][i]+a[<span class="hljs-number">3</span>][j]&lt;=<span class="hljs-number">10000</span>){
                ++t2[a[<span class="hljs-number">2</span>][i]+a[<span class="hljs-number">3</span>][j]];
            }
        }
    }
    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;
    <span class="hljs-comment">//这里直接循环把乘积算出来</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10000</span>;++i){
        sum+=(t1[i]*t2[<span class="hljs-number">10000</span>-i]);
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;sum;
}
</div></code></pre>
<h2 id="day-5">Day 5</h2>
<p>（讨厌的高精度水题 😕<br>
这题没什么好说的，直接写一个高精度乘法就行了。<br>
（朴素）高精度乘法的本质就是把多位数相乘分解为每一位的数相乘再乘上位数，和我们手算多位数乘法的原理相同。<br>
具体而言，假设两个两位数相乘：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mover accent="true"><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo>×</mo><mover accent="true"><mrow><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub></mrow><mo stretchy="true">‾</mo></mover></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>×</mo><mn>10</mn><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>1</mn></msub><mo>×</mo><mn>10</mn><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>+</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&amp;\overline{a_1a_2} \times \overline{b_1b_2}\\
&amp;= (a_1\times10+a_2)(b_1\times10+b_2)\\
&amp;= a_1b_1\times10^2\\
&amp; + (a_1b_2+a_2b_1)\times10^1\\
&amp;+a_2b_2\times10^0
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.6267640000000005em;vertical-align:-3.563382em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.063382000000001em;"><span style="top:-6.063382000000001em;"><span class="pstrut" style="height:2.89444em;"></span><span class="mord"></span></span><span style="top:-4.563382000000001em;"><span class="pstrut" style="height:2.89444em;"></span><span class="mord"></span></span><span style="top:-3.0392740000000003em;"><span class="pstrut" style="height:2.89444em;"></span><span class="mord"></span></span><span style="top:-1.5151660000000002em;"><span class="pstrut" style="height:2.89444em;"></span><span class="mord"></span></span><span style="top:0.008941999999999783em;"><span class="pstrut" style="height:2.89444em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.563382em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.063382000000001em;"><span style="top:-6.168942000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.89444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.81444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-4.668942em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.1448340000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-1.6207260000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span><span style="top:-0.09661800000000031em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.563382em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>而当我们使用数组来存储一个数的时候，这个数每一位的位数则刚好可以和数组的下标对应起来了，由此我们就可以相对简单地实现高精度乘法。<br>
需要注意的是，我们把一个数反过来存，比如对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>123</mn><mo>=</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup><mo>+</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">123=3\times10^0+2\times10^1+1\times10^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，我们使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mn>3</mn><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mn>2</mn><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">a_0=3, a_1=2, a_2=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，这样就可以刚好对应起来了。<br>
在进行乘法时，我们分别把每一位上的数相乘，把结果加到对应的位上。同时注意当某一位上的数大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 之后就需要进位。<br>
关于高精度数四则运算的详解可自行到 OI Wiki 食用：<a href="https://oi-wiki.org/math/bignum/">https://oi-wiki.org/math/bignum/</a></p>
<p>本题具体代码如下：</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span>
</span>{
    <span class="hljs-built_in">string</span> ret;
    ret.resize(a.size() + b.size());    <span class="hljs-comment">// 调整字符串大小，防止数组越界</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size(); ++i)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; b.size(); ++j)
        {
            ret[i + j] += (a[i] - <span class="hljs-string">'0'</span>) * (b[j] - <span class="hljs-string">'0'</span>);
            <span class="hljs-comment">// 把两位的乘积加到对应位上</span>
            <span class="hljs-comment">// 我是用的 std::string 存的这个数对应的字符串，因此需要把一位上的字符减去 '0' 得到对应的数</span>
            <span class="hljs-keyword">if</span> (ret[i + j] &gt;= <span class="hljs-number">10</span>)   <span class="hljs-comment">// 进位</span>
            {
                ret[i + j + <span class="hljs-number">1</span>] += ret[i + j] / <span class="hljs-number">10</span>;
                ret[i + j] %= <span class="hljs-number">10</span>;
            }
        }
    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ret.size(); ++i)
    {
        <span class="hljs-keyword">if</span> (ret[i])
            len = i + <span class="hljs-number">1</span>;
        ret[i] += <span class="hljs-string">'0'</span>;
    }
    ret.resize(len); <span class="hljs-comment">// 调整字符串的大小，去除前导零</span>
    <span class="hljs-keyword">return</span> ret;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-built_in">string</span> num1, num2;
    <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-built_in">cin</span> &gt;&gt; num1;
    reverse(num1.begin(), num1.end());  <span class="hljs-comment">// 把一个数反过来</span>
    <span class="hljs-keyword">while</span> (--n)
    {
        <span class="hljs-built_in">cin</span> &gt;&gt; num2;
        reverse(num2.begin(), num2.end());
        num1 = multiply(num1, num2);
    }
    copy(num1.rbegin(), num1.rend(), ostream_iterator&lt;<span class="hljs-keyword">char</span>&gt;{<span class="hljs-built_in">cout</span>}); <span class="hljs-comment">// 输出最后结果</span>
}

</div></code></pre>
<h2 id="day-6">Day 6</h2>
<p>这个长生不老的筒子看漫画很有特点--一本漫画必须在整数个小时内看完，而且非常专一--在单位时间内(小时)内不会看第二本书。</p>
<p>此外，这位筒子奢望可以享受阅读，尽可能要读得慢，于是最慢的速度是 1，最快的速度是 max(page[i])，所有答案不过是在这两个数之间，包括这两个数的整数。</p>
<p>于是可以想到用搜索算法找出最小正解即可。因为时间复杂度的要求，时间要尽可能缩短，所以二分搜索是好朋友。</p>
<p>下面是一位 caiji 的垃圾代码(这份代码的二分搜索其实很成问题，如果 begin &gt; end, return 回来的无法确定是比答案大还是小，于是处理复杂了点)。</p>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>, leavetime = <span class="hljs-number">0</span>, page[<span class="hljs-number">10001</span>] = {<span class="hljs-number">0</span>};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minpage)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;num, &amp;leavetime);
  <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; num + <span class="hljs-number">1</span>; i++) {
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;page[i]);
    <span class="hljs-keyword">if</span> (page[i] &gt; max) {
      max = page[i];<span class="hljs-comment">// 最多的书页</span>
    }
  }
  <span class="hljs-keyword">int</span> result = binary_search(<span class="hljs-number">1</span>, max);
  <span class="hljs-comment">// 在已知书页中寻找最佳页数，binarysearch如果能找到，找到也不一定最小</span>
  <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) {<span class="hljs-comment">// 所以以防万一加个判断</span>
    <span class="hljs-keyword">while</span> (result &gt; <span class="hljs-number">1</span> &amp;&amp; !judge(result - <span class="hljs-number">1</span>)) {
      result--;
    }  <span class="hljs-comment">//确保找到最小的那个</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, result);
  } <span class="hljs-keyword">else</span> {<span class="hljs-comment">// 没找到，说明答案是不是书页中的某个数</span>
    <span class="hljs-keyword">int</span> trial = -result;
    <span class="hljs-keyword">int</span> count1 = judge(trial + <span class="hljs-number">1</span>), count2 = judge(trial);
    <span class="hljs-keyword">while</span> (trial &gt;= <span class="hljs-number">1</span> &amp;&amp; !(count1 &gt; <span class="hljs-number">0</span> &amp;&amp; count2 &lt; <span class="hljs-number">0</span>)) {<span class="hljs-comment">// &gt;=1是防止出现1这种极端情况</span>
      <span class="hljs-keyword">if</span> (count2 &gt; <span class="hljs-number">0</span>) {<span class="hljs-comment">// 暴力搜索</span>
        trial--;
      } <span class="hljs-keyword">else</span> {
        trial++;
      }
      <span class="hljs-keyword">if</span> (trial &lt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">break</span>;
      }
      count1 = judge(trial + <span class="hljs-number">1</span>);
      count2 = judge(trial);<span class="hljs-comment">// 一个大于0一个小于0说明已经夹逼到了确定的数值</span>
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, trial + <span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>{
  <span class="hljs-keyword">int</span> medium = begin + (end - begin) / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span> (begin &gt; end) {
    <span class="hljs-keyword">return</span> -(end + <span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">int</span> result = judge(medium);
  <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> medium;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> binary_search(medium + <span class="hljs-number">1</span>, end);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> binary_search(begin, medium - <span class="hljs-number">1</span>);
  }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minpage)</span> </span>{
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; num + <span class="hljs-number">1</span>; i++) {
    <span class="hljs-keyword">if</span> (page[i] % minpage == <span class="hljs-number">0</span>) {
      count = count + page[i] / minpage;
    } <span class="hljs-keyword">else</span> {
      count = count + page[i] / minpage + <span class="hljs-number">1</span>;
    }
  }
  <span class="hljs-keyword">return</span> leavetime - count;<span class="hljs-comment">// 返回用minpage算出来的时间与班长返回时间的差值</span>
}
</div></code></pre>
<h2 id="day-7">Day 7</h2>
<p>这题考验的不是筒子们的算法功底，感觉更像是数学，或者说映射<br>
我们举个例子，就以 5 个数字为例<br>
1 2 3 4 5 -&gt; 1<br>
1 2 3 5 4 -&gt; 2 (1-&gt;2,4 和 5 互换)<br>
1 2 4 3 5 -&gt; 3 (2-&gt;3,3 和 4 互换,3 和 5 排序)<br>
1 2 4 5 3 -&gt; 4 (3-&gt;4,3 和 5 互换)<br>
1 2 5 3 4 -&gt; 5 (4-&gt;5,4 和 5 互换,3 和 4 排序)<br>
1 2 5 4 3 -&gt; 6 (5-&gt;6,3 和 4 互换)<br>
1 3 2 4 5 -&gt; 7 (6-&gt;7,2 和 3 互换,2、4、5 排序)<br>
所以能看出什么？每次+1 都伴随着一个交换和一次排序（没写排序的是因为后面其实是 1 个元素的排序）<br>
交换是较小数下标最大且较大数的数值最小的顺序组（即按从小到大排列的两个数）<br>
排序是交换后从原较小数的下标到最后的排序，那么逻辑就很清楚了<br>
上代码</p>
<pre><code class="language-c++"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n,add;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;add;
    <span class="hljs-keyword">int</span> a[n];
    <span class="hljs-comment">//输入，不做解释</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;a[i];
    }
    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>&amp;&amp;count&lt;add;--i){<span class="hljs-comment">//从后往前找下标最大的较小数</span>
        <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]&lt;a[i]){<span class="hljs-comment">//其实只要判断相邻两数即可，只要相邻的数一直是逆序整体一定逆序</span>
            <span class="hljs-keyword">int</span> min=i;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;n;++j){<span class="hljs-comment">//找后面的最小值，没什么好说的</span>
                <span class="hljs-keyword">if</span>(a[j]&lt;a[min]&amp;&amp;a[j]&gt;a[i<span class="hljs-number">-1</span>]){
                    min=j;
                }
            }
            <span class="hljs-keyword">int</span> temp=a[i<span class="hljs-number">-1</span>];
            a[i<span class="hljs-number">-1</span>]=a[min];
            a[min]=temp;
            sort(a,i,n<span class="hljs-number">-1</span>);
            ++count;
            i=n;
        }
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;a[n<span class="hljs-number">-1</span>]&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="day-8">Day 8</h2>
<p>（不这么讨厌的 dfs 水题 🤣</p>
<p>本讲解默认读者具有 dfs 的基础知识，还不会 dfs 的人请到 OI Wiki 自行食用：<a href="https://oi-wiki.org/search/dfs/">https://oi-wiki.org/search/dfs/</a></p>
<p>由于这题的数据规模非常小（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">n \le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>），我们可以直接考虑暴搜。
我们先把每两个字符串拼接后减少的长度算出来（如果无法拼接则设为一个不可能的值，比如我设为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>），之后直接 dfs 找最大的长度就行了。<br>
由于每个字符串最多只能用两次，我们也设置一个数组来存储使用的次数，当碰到已经用过两次的就直接跳过。同时，在 dfs 过程中也要维护这个数组的内容。</p>
<p>具体代码如下：</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> n;
<span class="hljs-built_in">string</span> str[<span class="hljs-number">20</span>];
<span class="hljs-keyword">int</span> cat_len[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mlen</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str1, <span class="hljs-built_in">string</span> str2)</span>  <span class="hljs-comment">// 计算两个字符出拼接后减少的长度，如果可以拼接则返回一个负数，如果不能则返回 0</span>
</span>{
    <span class="hljs-keyword">int</span> minlen = min(str1.length(), str2.length());
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; minlen; ++i)
        <span class="hljs-keyword">if</span> (str1.compare(str1.length() - i, i, str2, <span class="hljs-number">0</span>, i) == <span class="hljs-number">0</span>)
        <span class="hljs-comment">// 比较第一个字符串的末尾 length - i 个字符与第二个字符串的前 length - i 个字符</span>
            <span class="hljs-keyword">return</span> -i;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">int</span> usecnt[<span class="hljs-number">20</span>]; <span class="hljs-comment">// 每个字符使用的次数，dfs 过程中会更新</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curr)</span>
</span>{
    ++usecnt[curr]; <span class="hljs-comment">// 表示该字符串使用了一次</span>
    <span class="hljs-keyword">int</span> maxlen = <span class="hljs-number">0</span>; <span class="hljs-comment">// 以当前字符串开头的最大长度</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
        <span class="hljs-keyword">if</span> (usecnt[i] &lt; <span class="hljs-number">2</span> &amp;&amp; cat_len[curr][i] != <span class="hljs-number">0</span>)
            maxlen = max(maxlen, dfs(i) + cat_len[curr][i]);
            <span class="hljs-comment">// 更新最大长度</span>
    --usecnt[curr]; <span class="hljs-comment">// 退出一层递归的时候要把对应字符串的使用次数 - 1</span>
    <span class="hljs-keyword">return</span> maxlen + str[curr].length();
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
        <span class="hljs-built_in">cin</span> &gt;&gt; str[i];
    <span class="hljs-keyword">char</span> first;
    <span class="hljs-built_in">cin</span> &gt;&gt; first;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)
            cat_len[i][j] = mlen(str[i], str[j]);
    <span class="hljs-keyword">int</span> maxlen = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
        <span class="hljs-keyword">if</span> (str[i].front() == first)
            maxlen = max(maxlen, dfs(i));   <span class="hljs-comment">// 计算以第 i 个字符串开头的最大长度，并与之前所得的结果作比较</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; maxlen;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="day-9">Day 9</h2>
<p>难得一见的水题。</p>
<p>通过前序遍历可以求出整颗树，在改变一下前序遍历中左子树和右子树输出顺序再比较一不一样即可。当然这种方法需要将空结点也储存一下。</p>
<p>下面是一个 caiji 的代码。</p>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree</span> {</span>
  <span class="hljs-keyword">int</span> val;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree</span> *<span class="hljs-title">left</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree</span> *<span class="hljs-title">right</span>;</span>
} node;

<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>, store1[<span class="hljs-number">200</span>] = {<span class="hljs-number">0</span>}, store2[<span class="hljs-number">200</span>] = {<span class="hljs-number">0</span>};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create_tree</span><span class="hljs-params">(node **pnode)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_tree_1</span><span class="hljs-params">(node *pnode, <span class="hljs-keyword">int</span> *index)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_tree_2</span><span class="hljs-params">(node *pnode, <span class="hljs-keyword">int</span> *index)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  node *head1 = <span class="hljs-literal">NULL</span>;
  node *head2 = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;
  create_tree(&amp;head1);
  create_tree(&amp;head2);
  print_tree_1(head1, &amp;index1);
  print_tree_2(head2, &amp;index2);
  <span class="hljs-keyword">int</span> flag1 = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) {
    <span class="hljs-keyword">if</span> (store1[i] != store2[i]) {
      flag1 = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    }
  }
  <span class="hljs-keyword">if</span> (flag1) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create_tree</span><span class="hljs-params">(node **pnode)</span> </span>{
  <span class="hljs-keyword">int</span> realdata = <span class="hljs-number">0</span>;
  flag = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;realdata);
  <span class="hljs-keyword">if</span> (flag == EOF) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (realdata == <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">return</span>;
  }
  *pnode = (node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));
  (*pnode)-&gt;val = realdata;
  (*pnode)-&gt;left = <span class="hljs-literal">NULL</span>;
  (*pnode)-&gt;right = <span class="hljs-literal">NULL</span>;
  create_tree(&amp;((*pnode)-&gt;left));
  create_tree(&amp;((*pnode)-&gt;right));
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_tree_1</span><span class="hljs-params">(node *pnode, <span class="hljs-keyword">int</span> *index)</span> </span>{<span class="hljs-comment">// 前序遍历</span>
  <span class="hljs-keyword">if</span> (!pnode) {
    store1[*index] = <span class="hljs-number">-1</span>;
    (*index)++;
    <span class="hljs-keyword">return</span>;
  }
  store1[*index] = pnode-&gt;val;
  (*index)++;
  print_tree_1(pnode-&gt;left, index);
  print_tree_1(pnode-&gt;right, index);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_tree_2</span><span class="hljs-params">(node *pnode, <span class="hljs-keyword">int</span> *index)</span> </span>{<span class="hljs-comment">// 后两个反过来的前序遍历</span>
  <span class="hljs-keyword">if</span> (!pnode) {
    store2[*index] = <span class="hljs-number">-1</span>;
    (*index)++;
    <span class="hljs-keyword">return</span>;
  }
  store2[*index] = pnode-&gt;val;
  (*index)++;
  print_tree_2(pnode-&gt;right, index);
  print_tree_2(pnode-&gt;left, index);
}
</div></code></pre>
<h2 id="day-10">Day 10</h2>
<p>从这个题就能看出来出题人满满的恶意啊，<strong>不要使用递归方法解题</strong>，多么可恶<br>
不用递归当然就是循环咯，找到第一个右括号，找到和它匹配的左括号，然后把里面的东西展开，重复进行直到没有右括号为止<br>
不说废话了上代码</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;str;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str_b=<span class="hljs-string">""</span>,str_m=<span class="hljs-string">""</span>,str_e=<span class="hljs-string">""</span>;<span class="hljs-comment">//b表示前半部分，m是要重复的部分，e是后半部分</span>
    <span class="hljs-keyword">bool</span> count_r;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
        str_b=<span class="hljs-string">""</span>;str_m=<span class="hljs-string">""</span>;str_e=<span class="hljs-string">""</span>;
        count_r=<span class="hljs-literal">false</span>;
        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r,num=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> i;
        <span class="hljs-keyword">for</span>(r=<span class="hljs-number">0</span>;r&lt;str.size();++r){
            <span class="hljs-comment">//从前往后找右括号</span>
            <span class="hljs-keyword">if</span>(str[r]==<span class="hljs-string">']'</span>){
                count_r=<span class="hljs-literal">true</span>;
                <span class="hljs-comment">//从右括号往前找左括号</span>
                <span class="hljs-keyword">for</span>(l=r;l&gt;<span class="hljs-number">0</span>;--l){
                    <span class="hljs-keyword">if</span>(str[l]==<span class="hljs-string">'['</span>){
                        <span class="hljs-keyword">break</span>;
                    }
                }
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-comment">//没找到右括号就结束了</span>
        <span class="hljs-keyword">if</span>(!count_r){
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-comment">//算一下重复次数</span>
        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=l&amp;&amp;str[l-i]&gt;=<span class="hljs-string">'0'</span>&amp;&amp;str[l-i]&lt;=<span class="hljs-string">'9'</span>;++i){
            <span class="hljs-keyword">int</span> temp=<span class="hljs-number">1</span>;<span class="hljs-comment">//temp是表示位数，就是个十百千万之类的</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j){
                temp*=<span class="hljs-number">10</span>;
            }
            num+=(((str[l-i])<span class="hljs-number">-48</span>)*temp);
        }
        <span class="hljs-comment">//偷懒用了分割字符串的函数</span>
        str_b=str.substr(<span class="hljs-number">0</span>,l-i+<span class="hljs-number">1</span>);
        str_m=str.substr(l+<span class="hljs-number">1</span>,r-l<span class="hljs-number">-1</span>);
        str_e=str.substr(r+<span class="hljs-number">1</span>,str.size()-r<span class="hljs-number">-1</span>);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str4=<span class="hljs-string">""</span>;<span class="hljs-comment">//临时用来存重复之后的被重复部分</span>
        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;num;++i){
            str4=str4+str_m;
        }
        str=str_b+str4+str_e;
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="day-11">Day 11</h2>
<p>（并不讨厌的队列模拟水题 😙</p>
<p>这题就是模拟，我们按照列车出站的顺序考虑，具体的模拟逻辑如下：</p>
<ol>
<li>如果当前出站的列车恰好是进站的列车，那么就让这辆车直接过。</li>
<li>如果当前出站的列车恰好是站内的第一辆车，就让这辆车出站。</li>
<li>排除以上两种情况，则让当前进站的列车进站。</li>
</ol>
<p>而当一下情况出现的时候，那么就不能实现相应的顺序：</p>
<ol>
<li>最后一辆列车已经进站，但是站内的第一辆列车并不是需要出站的车。</li>
<li>需要某辆列车进站时，车站已满。</li>
</ol>
<p>根据上面的逻辑，我们就可以写出相应的代码了：</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> out[<span class="hljs-number">1000</span>];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> n, m;
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
        <span class="hljs-built_in">cin</span> &gt;&gt; out[i];
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; qu;  <span class="hljs-comment">// 车站内停靠的列车，用队列表示</span>
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 进、出站的车</span>
    <span class="hljs-keyword">bool</span> sgn = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 表示能否满足给定的顺序</span>
    <span class="hljs-keyword">while</span> (i &lt; n || !qu.empty())
    {
        <span class="hljs-keyword">while</span> (!qu.empty() &amp;&amp; qu.front() == out[j]) <span class="hljs-comment">// 站内第一辆车是需要出站的车</span>
        {
            qu.pop();
            ++j;
        }
        <span class="hljs-keyword">if</span> (i &lt; n)
        {
            <span class="hljs-keyword">if</span> (i == out[j])    <span class="hljs-comment">// 正要进站的车是需要出站的车</span>
            {
                ++i;
                ++j;
            }
            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 不满足上述情况</span>
                qu.push(i++);
        }
        <span class="hljs-keyword">if</span> (qu.size() &gt; m)  <span class="hljs-comment">// 站内的车总数大于车站容量</span>
        {
            sgn = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (i == n &amp;&amp; !qu.empty() &amp;&amp; qu.front() != out[j])  <span class="hljs-comment">// 列车已经全部进站但仍然无法满足</span>
        {
            sgn = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; (sgn ? <span class="hljs-string">"YES"</span> : <span class="hljs-string">"NO"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="day-12">Day 12</h2>
<p>这道题有很多种做法，但是很遗憾，作为小白只能使用最简单最无脑的做法--直接按层遍历。</p>
<p>如果不会二叉树按层遍历，google 欢迎您。</p>
<p>这道题别的做法有的突破点是结点是按顺序编号的，并且可以通过计算深度来判断层数。</p>
<p>下面是一个 caiji 的代码(按层遍历那个，c 语言选手什么都得自己实现，体谅一下，那一大堆函数除了 BFS 别的都不重要)。</p>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree</span> {</span>
  <span class="hljs-keyword">int</span> self;
  <span class="hljs-keyword">int</span> left;
  <span class="hljs-keyword">int</span> right;
} node;<span class="hljs-comment">// 自己，左子树，右子树</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue</span> {</span>
  node data[<span class="hljs-number">64</span>];
  <span class="hljs-keyword">int</span> front;
  <span class="hljs-keyword">int</span> rear;
  <span class="hljs-keyword">int</span> size;
} <span class="hljs-built_in">queue</span>;

<span class="hljs-keyword">int</span> maxsize = <span class="hljs-number">0</span>, real[<span class="hljs-number">30</span>][<span class="hljs-number">15</span>] = {<span class="hljs-number">0</span>};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(node store[], <span class="hljs-built_in">queue</span> aqueue)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create_queue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *target, <span class="hljs-keyword">int</span> max)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_queue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *target, node thedata)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_queue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *target, node *store)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_full</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> target)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> target)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, realresult[<span class="hljs-number">31</span>] = {<span class="hljs-number">0</span>};
  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;sum);
  <span class="hljs-built_in">queue</span> aqueue;
  create_queue(&amp;aqueue, <span class="hljs-number">64</span>);
  node store[sum + <span class="hljs-number">1</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; sum + <span class="hljs-number">1</span>; i++) {
    store[i].self = i;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;store[i].left, &amp;store[i].right);
  }
  store[<span class="hljs-number">0</span>].self = <span class="hljs-number">0</span>;
  BFS(store, aqueue);<span class="hljs-comment">// real[]里边已经存有各行的结点</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) {
    <span class="hljs-keyword">int</span> store = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">15</span>; j++) {
      <span class="hljs-keyword">if</span> (real[i][j] != <span class="hljs-number">0</span>) {
        store = real[i][j];
        realresult[count] = store;
        count++;
        <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">14</span>; j &gt;= <span class="hljs-number">0</span>; j--) {
      <span class="hljs-keyword">if</span> (real[i][j] != <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (real[i][j] != store) {
          realresult[count] = real[i][j];
          count++;
        }
        <span class="hljs-keyword">break</span>;
      }
    }
  }<span class="hljs-comment">// 寻找边界结点</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) {
    <span class="hljs-keyword">if</span> (!realresult[i + <span class="hljs-number">1</span>]) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, realresult[i]);
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, realresult[i]);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(node store[], <span class="hljs-built_in">queue</span> aqueue)</span> </span>{<span class="hljs-comment">// 最基本的按层遍历</span>
  <span class="hljs-keyword">int</span> count1 = <span class="hljs-number">0</span>, count2 = <span class="hljs-number">0</span>;
  enter_queue(&amp;aqueue, store[<span class="hljs-number">1</span>]);<span class="hljs-comment">// root 结点</span>
  enter_queue(&amp;aqueue, store[<span class="hljs-number">0</span>]);<span class="hljs-comment">// 换层标志</span>
  <span class="hljs-keyword">while</span> (!is_empty(aqueue)) {
    node tmp;
    delete_queue(&amp;aqueue, &amp;tmp);<span class="hljs-comment">// 出队列</span>
    <span class="hljs-keyword">if</span> (tmp.self) {<span class="hljs-comment">// 不是换层标志</span>
      real[count1][count2] = tmp.self;<span class="hljs-comment">// count1层，第count2个</span>
      count2++;
    } <span class="hljs-keyword">else</span> {
      count2 = <span class="hljs-number">0</span>;
      count1++;
      <span class="hljs-keyword">if</span> (!is_empty(aqueue)) {<span class="hljs-comment">// 队列没空</span>
        enter_queue(&amp;aqueue, store[<span class="hljs-number">0</span>]);<span class="hljs-comment">// 换层标志</span>
      }
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-number">-1</span>) {<span class="hljs-comment">// 左子树不空</span>
      enter_queue(&amp;aqueue, store[tmp.left]);
    }
    <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-number">-1</span>) {<span class="hljs-comment">// 右子树不空</span>
      enter_queue(&amp;aqueue, store[tmp.right]);
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create_queue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *target, <span class="hljs-keyword">int</span> max)</span> </span>{
  maxsize = max;
  target-&gt;front = <span class="hljs-number">0</span>;
  target-&gt;rear = <span class="hljs-number">0</span>;
  target-&gt;size = <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_queue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *target, node thedata)</span> </span>{
  <span class="hljs-keyword">if</span> (is_full(*target)) {
    <span class="hljs-keyword">return</span>;
  }
  target-&gt;data[target-&gt;rear] = thedata;
  target-&gt;size++;
  target-&gt;rear++;
  target-&gt;rear = target-&gt;rear % maxsize;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_queue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> *target, node *store)</span> </span>{
  <span class="hljs-keyword">if</span> (is_empty(*target)) {
    <span class="hljs-keyword">return</span>;
  }
  *store = target-&gt;data[target-&gt;front];
  target-&gt;front++;
  target-&gt;front = target-&gt;front % maxsize;
  target-&gt;size--;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_full</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> target)</span> </span>{
  <span class="hljs-keyword">if</span> (target.size == maxsize) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> target)</span> </span>{
  <span class="hljs-keyword">if</span> (target.size == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="day-13">Day 13</h2>
<p>这个题，我是真的很烦啊，爆肝了一整天，巨恶心<br>
连续学习最长时间，其实就是某段时间内认真学习天数的 2 倍大于某段时间<br>
那我们假设从第一天到第 i 天认真学习天数为 i0，到第 j 天为 j0，(i&lt;j)那么只要 2*(j0-i0)&lt;j-i 就说明第 i+1 天到第 j 天是认真学习的<br>
也就是 2*j0-j&lt;2*i0-i，那我们开一个数组里面就存 2*i0-i 即可<br>
但是实践发现这样效率不行，这样遍历去比较会超时，那么就用空间换时间<br>
再开一个新的数组，下标 k 对应的内容是满足 2*i0-i&lt;k-n 的最小的 i，因为最小的天数对应最长的时间<br>
我们只需要把每一个第 i 天的值加上 n 当作下标得到一个天数，用 i 和那个天数作差就能得到结果了<br>
然后把最大的那个结果输出就行了<br>
上代码</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n,cnt_s=<span class="hljs-number">0</span>,temp,max=<span class="hljs-number">0</span>;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);
    <span class="hljs-keyword">int</span> v[n+<span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> t[<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>];
    v[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//这里虚构了一个第0天，因为如果从第一天开始到第i天的话需要的应该是第0天的值，显然应该是0</span>
    <span class="hljs-comment">//将后半部分置为0是因为k&gt;n时k-n&gt;0即第0天的值，不会有比第0天更小的天数了</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i){
        t[i]=<span class="hljs-number">-1</span>;
        t[n+i]=<span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;++i){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;temp;
        <span class="hljs-keyword">if</span>(temp&gt;<span class="hljs-number">8</span>){
            ++cnt_s;
        }
        v[i]=<span class="hljs-number">2</span>*cnt_s-i;
        <span class="hljs-comment">//这里因为天数是从小到大的，正好符合我们说的那个最小的天数，没赋值的赋值，赋值了的不用改（因为赋值过的天数一定更小</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*cnt_s-i+n+<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>*n&amp;&amp;t[j]==<span class="hljs-number">-1</span>;++j){
            t[j]=i;
        }
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;++i){
        <span class="hljs-comment">//找到最大的差值就行了</span>
        <span class="hljs-keyword">if</span>(t[v[i]+n]!=<span class="hljs-number">-1</span>&amp;&amp;i-t[v[i]+n]&gt;max){
            max=i-t[v[i]+n];
        }
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;max;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>这个方法从代码上看很像 o(n^2)但实际上应该是 o(n)的
注：感谢 czg 大佬对最后一步的提醒</p>
<h2 id="day-14">Day 14</h2>
<p>（还行的拓扑排序水题 😵</p>
<p>本讲解默认读者具有图论和拓扑排序的基本知识，否则请到 OI Wiki 或《离散数学结构》自行食用。<br>
图论基本概念：<a href="https://oi-wiki.org/graph/concept/">https://oi-wiki.org/graph/concept/</a>、《离散数学结构》4.2、4.3<br>
拓扑排序：<a href="https://oi-wiki.org/graph/topo/">https://oi-wiki.org/graph/topo/</a></p>
<p>知道了上面的东西这题也就自然解决了吧？我们把每个人看作一个点，把一个人排在另一个人的前面这个关系作为一条有向边，之后拓扑排序即可得到结果。<br>
不过由于需要字典序最小，我们可以使用一个优先队列来代替拓扑排序中原本所用的队列。</p>
<p>具体代码如下：</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">600000</span>;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nodes[maxn];    <span class="hljs-comment">// 某个学生所连的边</span>
<span class="hljs-keyword">int</span> in[maxn];   <span class="hljs-comment">// 入度</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> n, m;
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)
    {
        <span class="hljs-keyword">int</span> f, t;
        <span class="hljs-built_in">cin</span> &gt;&gt; f &gt;&gt; t;
        nodes[f].emplace_back(t);
        ++in[t];
    }
    <span class="hljs-comment">// 下面在拓扑排序的过程中输出结果</span>
    priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; pq;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
        <span class="hljs-keyword">if</span> (in[i] == <span class="hljs-number">0</span>)
            pq.push(i);
    <span class="hljs-keyword">while</span> (!pq.empty())
    {
        <span class="hljs-keyword">int</span> n = pq.top();
        pq.pop();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t : nodes[n])
        {
            --in[t];
            <span class="hljs-keyword">if</span> (in[t] == <span class="hljs-number">0</span>)
                pq.push(t);
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; (pq.empty() ? <span class="hljs-string">""</span> : <span class="hljs-string">" "</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="day-15">Day 15</h2>
<p>这是一道深搜。只要不断地切割字符串，然后判断是否有不符合条件的数字存在，不符合条件就 return，最后自然会剩下一个解，输出即可。</p>
<p>切割字符串的长度是 1 或者 2，如果出现有数字&gt;m 的，或者出现重复数字的，就是不符合要求。为了节省时间，设一个 flag，只要已经找到了，一路退出，不在别的查找上浪费时间。</p>
<p>下面是一个 caiji 的代码。</p>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxsize = <span class="hljs-number">50</span>, maxcapacity = <span class="hljs-number">100</span>;
<span class="hljs-keyword">int</span> state[<span class="hljs-number">50</span>], result[<span class="hljs-number">50</span>], flag = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;
<span class="hljs-comment">// state存储数字是否已经存在，result存储当前找到的</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slice</span><span class="hljs-params">(<span class="hljs-keyword">char</span> store[], <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> sum)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">char</span> store[<span class="hljs-number">100</span>] = {<span class="hljs-number">0</span>};
  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, store);
  slice(store, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);从<span class="hljs-number">0</span>开始，当前一共<span class="hljs-number">0</span>个
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slice</span><span class="hljs-params">(<span class="hljs-keyword">char</span> store[], <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> sum)</span> </span>{
  <span class="hljs-keyword">if</span> (flag) {<span class="hljs-comment">// 已经找到</span>
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (max == sum &amp;&amp; (index &gt; maxcapacity - <span class="hljs-number">1</span> || !store[index])) {<span class="hljs-comment">// 找到了！</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sum - <span class="hljs-number">1</span>; i++) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, result[i]);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, result[sum - <span class="hljs-number">1</span>]);
    flag = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">int</span> count1 = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; index + <span class="hljs-number">1</span> &amp;&amp; store[i]; i++) {<span class="hljs-comment">// 切一个，即下一个数为个位数</span>
    count1 = count1 * <span class="hljs-number">10</span> + store[i] - <span class="hljs-string">'0'</span>;
  }
  <span class="hljs-keyword">if</span> (count1 &amp;&amp; count1 &lt;= maxsize &amp;&amp; !state[count1]) {
    <span class="hljs-keyword">int</span> tmp = max;<span class="hljs-comment">// 存储当前max值</span>
    <span class="hljs-keyword">if</span> (count1 &gt; max) {
      max = count1;
    }
    state[count1] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 改状态</span>
    result[sum] = count1;<span class="hljs-comment">// 结果数组里边存储这个值</span>
    slice(store, index + <span class="hljs-number">1</span>, sum + <span class="hljs-number">1</span>);<span class="hljs-comment">// 深搜</span>
    <span class="hljs-keyword">if</span> (flag) {<span class="hljs-comment">// 找到了！</span>
      <span class="hljs-keyword">return</span>;
    }
    max = tmp;<span class="hljs-comment">// max恢复</span>
    state[count1] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 状态改回来</span>
    result[sum] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 结果数组扔掉这个值</span>
  }
  <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; index + <span class="hljs-number">2</span> &amp;&amp; store[i]; i++) {
    count2 = count2 * <span class="hljs-number">10</span> + store[i] - <span class="hljs-string">'0'</span>;
  }
  <span class="hljs-keyword">if</span> (count2 &gt;= <span class="hljs-number">10</span> &amp;&amp; count2 &lt;= maxsize &amp;&amp; !state[count2]) {
    <span class="hljs-keyword">int</span> tmp = max;
    <span class="hljs-keyword">if</span> (count2 &gt; max) {
      max = count2;
    }
    state[count2] = <span class="hljs-number">1</span>;
    result[sum] = count2;
    slice(store, index + <span class="hljs-number">2</span>, sum + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (flag) {
      <span class="hljs-keyword">return</span>;
    }
    max = tmp;
    state[count2] = <span class="hljs-number">0</span>;
    result[sum] = <span class="hljs-number">0</span>;
  }
}
</div></code></pre>
<h2 id="day-16">Day 16</h2>
<p>这个题就还可以吧，就是看能保证身高体重同时上升的最大长度问题<br>
我们可以先按照某一要素（身高或者体重）排序，然后再看另一个要素<br>
现在它们已经按某一个要素排好序了（假设是升序），那么最前面的一些只能当顶部，也就是最前面那些最大长度只能是 1<br>
之后看后面的人，如果他能上面能放人，那他当底部对应的最大长度就是他上面能放的人中长度最长的那个再加 1<br>
由于前面的每一个我们都处理过了，那么每个人的最大长度就确定了，找到最大的那个就行了<br>
上代码</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-comment">//定义了一个类，只是为了看起来方便，其实就是存了两个int</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">people</span>{</span>
    <span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> h=<span class="hljs-number">0</span>;<span class="hljs-comment">//身高</span>
    <span class="hljs-keyword">int</span> w=<span class="hljs-number">0</span>;<span class="hljs-comment">//体重</span>
    <span class="hljs-comment">//这里我定义了一个对两个人的比较用的小于号方法，其实就是身高体重均小于</span>
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> people &amp;a){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;h&lt;a.h&amp;&amp;<span class="hljs-keyword">this</span>-&gt;w&lt;a.wreturn;
    }
};
<span class="hljs-comment">//排序，详见Day1,只是把排序的变量变成了people类型，比较的方式变成的身高而已</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(people a[],<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> e)</span></span>{
    <span class="hljs-keyword">int</span> i=b,j=e;
    <span class="hljs-keyword">int</span> k=a[b].h;
    <span class="hljs-keyword">if</span>(b&gt;=e)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">while</span>(i&lt;j){
        <span class="hljs-keyword">while</span>(a[i].h&lt;k&amp;&amp;i&lt;e){
            i++;
        }
        <span class="hljs-keyword">while</span>(a[j].h&gt;=k&amp;&amp;j&gt;b){
            j--;
        }
        <span class="hljs-keyword">if</span>(i&lt;j){
            people temp=a[i];
            a[i]=a[j];
            a[j]=temp;
        }
    }
    sort(a,b,j);
    sort(a,j+<span class="hljs-number">1</span>,e);
    <span class="hljs-keyword">return</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n,max=<span class="hljs-number">0</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;n;
    people p[n];
    <span class="hljs-keyword">int</span> length[n];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;p[i].h&gt;&gt;p[i].w;
        length[i]=<span class="hljs-number">0</span>;
    }
    sort(p,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j){
            <span class="hljs-keyword">if</span>(p[j]&lt;p[i]){<span class="hljs-comment">//这个比较就是我在class people里写的小于号方法</span>
                <span class="hljs-comment">//这里就是对每一个小于他的去比较长度，取最大的那个</span>
                length[i]=(length[j]&gt;length[i]?length[j]:length[i]);
            }
        }
        <span class="hljs-comment">//加上他自己</span>
        ++length[i];
        <span class="hljs-comment">//判断最大值</span>
        max=(max&gt;length[i]?max:length[i]);
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;max&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；
}
</div></code></pre>
<h2 id="day-17">Day 17</h2>
<p>（有点难的二分图水题 🥴</p>
<p>本题解假设读者具有图论、二分图和二分猜答案的基本知识，否则请到 OI Wiki、《离散数学结构》自行食用。<br>
图论：参见 Day 14 题解<br>
二分图：<a href="https://oi-wiki.org/graph/bi-graph/">https://oi-wiki.org/graph/bi-graph/</a><br>
二分猜答案：<a href="https://oi-wiki.org/basic/binary/">https://oi-wiki.org/basic/binary/</a></p>
<p>这题的描述再清楚不过了，你们就不用我说该怎么写了吧？<br>
（显然如果某个比较小的破坏值可以满足要求，那么比较大的破坏值一定可以满足，于是我们可以猜答案然后用二分图来验证</p>
<p>具体代码如下：</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>
{</span>
    <span class="hljs-keyword">int</span> to; <span class="hljs-comment">// 所连另一位同学的编号</span>
    <span class="hljs-keyword">int</span> destruction;    <span class="hljs-comment">// 这一对的破坏值</span>
};
<span class="hljs-built_in">vector</span>&lt;Edge&gt; stu[<span class="hljs-number">20001</span>];    <span class="hljs-comment">// 班级里的同学</span>
<span class="hljs-keyword">int</span> n, m;
<span class="hljs-keyword">int</span> sat[<span class="hljs-number">20001</span>]; <span class="hljs-comment">// 某个同学是在第一组还是第二组</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">chk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> max_des)</span>
</span>{
    fill_n(sat, <span class="hljs-number">20001</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// 所有同学最初都未分配</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)
        <span class="hljs-keyword">if</span> (sat[i] == <span class="hljs-number">-1</span>)
        {
            sat[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 未分配的可以任意分配，这里分配到第一组</span>
            <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; qu;
            qu.push(i);
            <span class="hljs-keyword">while</span> (!qu.empty())
            {
                <span class="hljs-keyword">int</span> t = qu.front();
                qu.pop();
                <span class="hljs-keyword">for</span> (Edge e : stu[t])
                {
                    <span class="hljs-keyword">if</span> (e.destruction &lt;= max_des)   <span class="hljs-comment">// 由于每个同学的边已经按照破坏值排序，所以直接跳过</span>
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">if</span> (sat[e.to] == <span class="hljs-number">1</span> - sat[t])    <span class="hljs-comment">// 所连的同学已经被分配到了另一个组；跳过</span>
                        <span class="hljs-keyword">continue</span>;
                    <span class="hljs-keyword">if</span> (sat[e.to] == sat[t])    <span class="hljs-comment">// 两者分配到了同一个组，不满足要求</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    sat[e.to] = <span class="hljs-number">1</span> - sat[t]; <span class="hljs-comment">// 分配到另一个组</span>
                    qu.push(e.to);
                }
            }
        }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">int</span> maxd = <span class="hljs-number">0</span>, mind = INT32_MAX; <span class="hljs-comment">// 二分的上下界</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)
    {
        <span class="hljs-keyword">int</span> x, y, p;
        <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; p;
        stu[x].push_back({y, p});
        stu[y].push_back({x, p});
        maxd = max(maxd, p);
        mind = min(mind, p);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)
        sort(stu[i].begin(), stu[i].end(), [](Edge a, Edge b) { <span class="hljs-keyword">return</span> a.destruction &gt; b.destruction; });
        <span class="hljs-comment">// 将一个同学所连的边按照破坏值从大到小排序</span>
    mind = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> mid;
    <span class="hljs-keyword">for</span> (mid = (maxd + mind) / <span class="hljs-number">2</span>; mind &lt; maxd - <span class="hljs-number">1</span>; mid = (maxd + mind) / <span class="hljs-number">2</span>)
    <span class="hljs-comment">// 二分猜</span>
    {
        <span class="hljs-keyword">if</span> (chk(mid))
            maxd = mid;
        <span class="hljs-keyword">else</span>
            mind = mid;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; maxd;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="day-18">Day 18</h2>
<p>关于<a href="https://blog.csdn.net/qq_35644234/article/details/60870719?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">dijkstra 算法</a></p>
<p>先抽象一下数据结构，这是一个无向有权图，最大结点数是 1000，不算大，为了时间可以使用邻接矩阵来储存数据。</p>
<p>然后就用 dijkstra 算法就行了，除了判断这条路能不能走(不能把驾驶员累着)，没有什么多余的措施。</p>
<p>这是一个 caiji 的代码。</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">graph</span> {</span><span class="hljs-comment">// 图，邻接矩阵</span>
 <span class="hljs-keyword">public</span>:
  graph(<span class="hljs-keyword">int</span> vertex = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> edge = <span class="hljs-number">0</span>);
  ~graph();
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creategraph</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>;
  <span class="hljs-keyword">bool</span> *distate;<span class="hljs-comment">// 是否已经确定0 到这个点的最短路径</span>
  <span class="hljs-keyword">int</span> *dis;<span class="hljs-comment">// 最短路径存储数组，不一定是确定值，正数表示驾驶员1可以走，负数反之</span>
  <span class="hljs-keyword">int</span> vertex;
  <span class="hljs-keyword">int</span> edge;
  <span class="hljs-keyword">int</span> **matrix;<span class="hljs-comment">// 矩阵</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = __INT_MAX__;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> vertex, edge;
  <span class="hljs-built_in">cin</span> &gt;&gt; vertex &gt;&gt; edge;
  <span class="hljs-function">graph <span class="hljs-title">one</span><span class="hljs-params">(vertex, edge)</span></span>;
  one.creategraph();
  one.dijkstra();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; one.vertex; i++) {
    <span class="hljs-keyword">if</span> (one.dis[i] == INF) {
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">' '</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">abs</span>(one.dis[i]) &lt;&lt; <span class="hljs-string">' '</span>;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

graph::graph(<span class="hljs-keyword">int</span> vertex, <span class="hljs-keyword">int</span> edge) {<span class="hljs-comment">// 构造函数</span>
  <span class="hljs-keyword">this</span>-&gt;vertex = vertex;
  <span class="hljs-keyword">this</span>-&gt;edge = edge;
  <span class="hljs-keyword">this</span>-&gt;matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> *[vertex];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertex; i++) {
    <span class="hljs-keyword">this</span>-&gt;matrix[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vertex];
  }
  <span class="hljs-keyword">this</span>-&gt;dis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vertex];
  <span class="hljs-keyword">this</span>-&gt;distate = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[vertex];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertex; i++) {
    <span class="hljs-keyword">this</span>-&gt;dis[i] = INF;
    <span class="hljs-keyword">this</span>-&gt;distate[i] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; vertex; j++) {
      <span class="hljs-keyword">this</span>-&gt;matrix[i][j] = INF;
    }
  }
  <span class="hljs-keyword">this</span>-&gt;dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>-&gt;distate[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;
}

graph::~graph() {<span class="hljs-comment">// 析构函数</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;vertex; i++) {
    <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;matrix[i];
  }
  <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;matrix;
  <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;dis;
  <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;distate;
}

<span class="hljs-keyword">void</span> graph::creategraph() {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;edge; i++) {
    <span class="hljs-keyword">int</span> ori, des, wei, who;
    <span class="hljs-built_in">cin</span> &gt;&gt; ori &gt;&gt; des &gt;&gt; wei &gt;&gt; who;
    <span class="hljs-keyword">this</span>-&gt;matrix[ori][des] = <span class="hljs-keyword">this</span>-&gt;matrix[des][ori] = (who == <span class="hljs-number">1</span>) ? wei : -wei;<span class="hljs-comment">// 驾驶员</span>
    <span class="hljs-keyword">if</span> (!ori) {
      <span class="hljs-keyword">this</span>-&gt;dis[des] = wei;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!des) {
      <span class="hljs-keyword">this</span>-&gt;dis[ori] = wei;
    }
  }
}

<span class="hljs-keyword">void</span> graph::dijkstra() {
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<span class="hljs-comment">// count表示已经确定几个结点，1表示确定了0自己</span>
  <span class="hljs-keyword">while</span> (count != <span class="hljs-keyword">this</span>-&gt;vertex) {
    <span class="hljs-keyword">int</span> minindex = <span class="hljs-number">0</span>, min = INF;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;vertex; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;distate[i] &amp;&amp; <span class="hljs-built_in">abs</span>(<span class="hljs-keyword">this</span>-&gt;dis[i]) &lt; <span class="hljs-built_in">abs</span>(min)) {<span class="hljs-comment">// 找到当前最小</span>
        minindex = i;
        min = <span class="hljs-keyword">this</span>-&gt;dis[i];
      }
    }
    <span class="hljs-keyword">this</span>-&gt;distate[minindex] = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 找到后确认最短路径</span>
    count++;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;vertex; i++) {<span class="hljs-comment">// 判断以该节点为中介，可不可以得到通向别的结点的最小值</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;distate[i] &amp;&amp; <span class="hljs-keyword">this</span>-&gt;matrix[minindex][i] != INF &amp;&amp;
          min * <span class="hljs-keyword">this</span>-&gt;matrix[minindex][i] &lt; <span class="hljs-number">0</span> &amp;&amp;
          (<span class="hljs-built_in">abs</span>(min) + <span class="hljs-built_in">abs</span>(<span class="hljs-keyword">this</span>-&gt;matrix[minindex][i])) &lt; <span class="hljs-built_in">abs</span>(<span class="hljs-keyword">this</span>-&gt;dis[i])) {
        <span class="hljs-keyword">int</span> tmp = <span class="hljs-built_in">abs</span>(min) + <span class="hljs-built_in">abs</span>(<span class="hljs-keyword">this</span>-&gt;matrix[minindex][i]);
        <span class="hljs-keyword">this</span>-&gt;dis[i] = (min &gt; <span class="hljs-number">0</span>) ? -tmp : tmp;<span class="hljs-comment">// 保持正负号以便判断接下来走向</span>
      }
    }
  }
}
</div></code></pre>
<h2 id="day-19">Day 19</h2>
<p>这个题在我看来和 Day17 的捣蛋鬼那题是一样的，czg 大佬在 Day17 的题中使用的是二分图判断答案是否正确，而我是用的染色法<br>
这题也可以染色，我们把每支军队看成一个点，每句话都可以得到一些关系，从而确定两个点的颜色关系，将两个点连线（放到同一个数组里）<br>
已经连上线的一定不会是假话，但是如果某一句话涉及和之前的话（已连接出来的线）无关的东西怎么办呢？没关系，新建一条线就好了<br>
新线上的点是什么颜色不重要，只要保证相对关系即可。当两个之前毫无关系的线相连的时候，如果颜色恰好和那句话的表述相同就没问题，如果不同就把其中一条线上的点颜色同时向后推移某一个定值，由于相互关系并没有改变所以这并不影响之前的话的成立性。<br>
如果是同一根线上的两个点相连，如果颜色没有问题就是真话，否则就是假话，忽略本次连线<br>
理论说完了，上代码</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-comment">//又是一个为了好看弄的类，其实就是两个int</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">army</span>{</span>
    <span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> c=<span class="hljs-number">-1</span>;<span class="hljs-comment">//0胜1胜2,其中0,1,2表示三个国家（三种颜色）</span>
    <span class="hljs-keyword">int</span> index=<span class="hljs-number">-1</span>;<span class="hljs-comment">//表示在哪一根线上</span>
};
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n,m,count=<span class="hljs-number">0</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;
    army a[n+<span class="hljs-number">1</span>];
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; v;
    <span class="hljs-keyword">int</span> kind=<span class="hljs-number">0</span>,a1,a2;<span class="hljs-comment">//kind是两个军队的关系，a1，a2是军队编号</span>
    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;kind&gt;&gt;a1&gt;&gt;a2;
        <span class="hljs-comment">//军队编号超过n肯定是不对的</span>
        <span class="hljs-keyword">if</span>(a1&gt;n||a2&gt;n){
            ++count;
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">if</span>(kind==<span class="hljs-number">1</span>){<span class="hljs-comment">//同一国家</span>
            <span class="hljs-comment">//两军队是同一个那么同国家肯定是对的，不用做任何处理</span>
            <span class="hljs-keyword">if</span>(a1==a2){
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">//如果两个军队都没被染过色</span>
            <span class="hljs-keyword">if</span>(a[a1].c==<span class="hljs-number">-1</span>&amp;&amp;a[a2].c==<span class="hljs-number">-1</span>){
                <span class="hljs-comment">//新建一条线</span>
                v.push_back({});
                v[index].push_back(a1);
                v[index].push_back(a2);
                a[a1].index=index;
                a[a2].index=index;
                <span class="hljs-comment">//给这两个军队随便染个相同的颜色，这里选择0</span>
                a[a1].c=<span class="hljs-number">0</span>;
                a[a2].c=<span class="hljs-number">0</span>;
                ++index;
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">//一个染色一个未染色，直接放同一个线上染同一个色就行</span>
            <span class="hljs-keyword">if</span>(a[a1].c==<span class="hljs-number">-1</span>&amp;&amp;a[a2].c!=<span class="hljs-number">-1</span>){
                a[a1].index=a[a2].index;
                v[a[a2].index].push_back(a1);
                a[a1].c=a[a2].c;
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span>(a[a2].c==<span class="hljs-number">-1</span>&amp;&amp;a[a1].c!=<span class="hljs-number">-1</span>){
                a[a2].index=a[a1].index;
                v[a[a1].index].push_back(a2);
                a[a2].c=a[a1].c;
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">//两个都染过色了</span>
            <span class="hljs-keyword">if</span>(a[a1].c!=<span class="hljs-number">-1</span>&amp;&amp;a[a2].c!=<span class="hljs-number">-1</span>){
                <span class="hljs-keyword">if</span>(a[a1].c!=a[a2].c){
                    <span class="hljs-comment">//颜色不一样看是不是同一条线，同线就是假话，否则改掉其中一条线全部颜色，两条线合并</span>
                    <span class="hljs-keyword">if</span>(a[a1].index==a[a2].index){
                        ++count;
                        <span class="hljs-keyword">continue</span>;
                    }
                    <span class="hljs-keyword">else</span>{
                        <span class="hljs-keyword">int</span> temp=a[a2].c-a[a1].c;
                        <span class="hljs-keyword">int</span> idx=a[a1].index;
                        <span class="hljs-keyword">int</span> index1=a[a2].index;
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;v[idx].size();++j){
                            a[v[idx][j]].index=index1;
                            a[v[idx][j]].c=(a[v[idx][j]].c+temp+<span class="hljs-number">3</span>)%<span class="hljs-number">3</span>;
                            v[index1].push_back(v[idx][j]);
                        }
                        v[idx].clear();
                    }
                }
                <span class="hljs-keyword">else</span>{
                    <span class="hljs-comment">//颜色一样同一条线不做处理，不同的线直接合并</span>
                    <span class="hljs-keyword">if</span>(a[a1].index==a[a2].index){
                        <span class="hljs-keyword">continue</span>;
                    }
                    <span class="hljs-keyword">else</span>{
                        <span class="hljs-keyword">int</span> idx=a[a1].index;
                        <span class="hljs-keyword">int</span> index1=a[a2].index;
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;v[idx].size();++j){
                            a[v[idx][j]].index=index1;
                            v[index1].push_back(v[idx][j]);
                        }
                        v[idx].clear();
                    }
                }
            }
        }
        <span class="hljs-keyword">else</span>{<span class="hljs-comment">//a1战胜a2</span>
            <span class="hljs-comment">//我杀我自己肯定是不行的</span>
            <span class="hljs-keyword">if</span>(a1==a2){
                ++count;
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">//其实后面的和上半部分差不多，只是相同颜色变成了胜负关系要注意对3取模</span>
            <span class="hljs-comment">//两个未染色</span>
            <span class="hljs-keyword">if</span>(a[a1].c==<span class="hljs-number">-1</span>&amp;&amp;a[a2].c==<span class="hljs-number">-1</span>){
                v.push_back({});
                v[index].push_back(a1);
                v[index].push_back(a2);
                a[a1].index=index;
                a[a2].index=index;
                a[a1].c=<span class="hljs-number">0</span>;
                a[a2].c=<span class="hljs-number">1</span>;
                ++index;
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">//一个染色一个没有</span>
            <span class="hljs-keyword">if</span>(a[a1].c==<span class="hljs-number">-1</span>&amp;&amp;a[a2].c!=<span class="hljs-number">-1</span>){
                a[a1].index=a[a2].index;
                v[a[a2].index].push_back(a1);
                a[a1].c=(a[a2].c+<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>;
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span>(a[a2].c==<span class="hljs-number">-1</span>&amp;&amp;a[a1].c!=<span class="hljs-number">-1</span>){
                a[a2].index=a[a1].index;
                v[a[a1].index].push_back(a2);
                a[a2].c=(a[a1].c+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>;
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">//两个都染色</span>
            <span class="hljs-keyword">if</span>(a[a1].c!=<span class="hljs-number">-1</span>&amp;&amp;a[a2].c!=<span class="hljs-number">-1</span>){
                <span class="hljs-keyword">if</span>((a[a1].c+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>!=a[a2].c){
                    <span class="hljs-comment">//不符合战胜关系</span>
                    <span class="hljs-keyword">if</span>(a[a1].index==a[a2].index){
                        ++count;
                        <span class="hljs-keyword">continue</span>;
                    }
                    <span class="hljs-keyword">else</span>{
                        <span class="hljs-keyword">int</span> temp=a[a1].c-a[a2].c;
                        <span class="hljs-keyword">int</span> idx=a[a2].index;
                        <span class="hljs-keyword">int</span> index1=a[a1].index;
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;v[idx].size();++j){
                            a[v[idx][j]].index=index1;
                            a[v[idx][j]].c=(a[v[idx][j]].c+temp+<span class="hljs-number">4</span>)%<span class="hljs-number">3</span>;
                            v[index1].push_back(v[idx][j]);
                        }
                        v[idx].clear();
                    }
                }
                <span class="hljs-keyword">else</span>{
                    <span class="hljs-comment">//符合战胜关系</span>
                    <span class="hljs-keyword">if</span>(a[a1].index==a[a2].index){
                        <span class="hljs-keyword">continue</span>;
                    }
                    <span class="hljs-keyword">else</span>{
                        <span class="hljs-keyword">int</span> idx=a[a1].index;
                        <span class="hljs-keyword">int</span> index1=a[a2].index;
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;v[idx].size();++j){
                            a[v[idx][j]].index=index1;
                            v[index1].push_back(v[idx][j]);
                        }
                        v[idx].clear();
                    }
                }
            }
        }
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>这个代码又臭又长，主要是上下部分基本上一样但是我又没有写成函数的原因。。。<br>
<s>才不会告诉你们是我懒直接 CTRL+C/V 了</s></p>
<h2 id="day-20">Day 20</h2>
<p>（可能是全场最难的树的直径水题 🤢<br>
我们先从一个看起来和这道题毫不相关的点开始：<br>
在一棵树中，从一个结点出发，遍历这棵树的所有节点，最后回到这个节点，所经过的边数最少是多少？<br>
答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 条，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是这棵树的节点个数。<br>
我们考虑从一个父节点到一个子节点再回来，那么这个父节点与子节点之间的那条边就经过了两次；逐层递归可得从开始的那个节点（根节点）经过这个过程，树的每一条边都经过了两次。</p>
<p>那么这和我们的这道题有什么关系呢？<br>
这道题中我们依然要遍历所有的节点，唯一的差别是不需要回到开始的那个节点。容易证明这样我们最多可以少经过从开始节点到结束节点的那条路径上的所有的边一次。<br>
于是这道题就转化成了找出合适的开始和结束节点使得他们之间的距离是一棵树上最长的一条简单路径（即树的直径）。</p>
<p>关于树的直径的求法，有以下定理：</p>
<p>到树上任意一点的距离最长的一点必定是直径的一个端点。</p>
<p>这个定理的具体证明见这个网页：<br>
<a href="https://ikely.me/2014/09/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/">https://ikely.me/2014/09/21/树的直径/</a></p>
<p>于是我们先从任意一点 dfs 或 bfs 找出距离最大的一个点，然后从这个点重复一次，就可以找出直径的长度了。</p>
<p>具体代码如下：</p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    <span class="hljs-keyword">int</span> edges[<span class="hljs-number">3</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>};    <span class="hljs-comment">// 与一个二叉树上的一个节点所连的点最多有三个</span>
    <span class="hljs-keyword">int</span> parent = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 到根节点的距离</span>
};
Node arr[<span class="hljs-number">100000</span>];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curr, <span class="hljs-keyword">int</span> depth, <span class="hljs-keyword">int</span> parent)</span>    <span class="hljs-comment">// 第二次 dfs</span>
</span>{
    <span class="hljs-keyword">int</span> maxd = depth;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span> &amp;&amp; arr[curr].edges[i] != <span class="hljs-number">-1</span>; ++i)
    {
        <span class="hljs-keyword">if</span> (arr[curr].edges[i] == parent)
            <span class="hljs-keyword">continue</span>;
        maxd = max(maxd, dfs(arr[curr].edges[i], depth + <span class="hljs-number">1</span>, curr));
    }
    <span class="hljs-keyword">return</span> maxd;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-keyword">int</span> maxd = <span class="hljs-number">0</span>, maxdi;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
    {
        <span class="hljs-keyword">int</span> t;
        <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;
        arr[i].edges[<span class="hljs-number">0</span>] = arr[i].parent;    <span class="hljs-comment">// 添加父节点与子节点之间连的边</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; ++j)
        {
            <span class="hljs-built_in">cin</span> &gt;&gt; t;
            <span class="hljs-keyword">if</span> (t != <span class="hljs-number">-1</span>)
            {
                <span class="hljs-comment">// 我在输入数据的同时也在进行第一次遍历，大家不要学我</span>
                arr[i].edges[k++] = t;
                arr[t].parent = i;
                arr[t].depth = arr[i].depth + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (arr[t].depth &gt; maxd)    <span class="hljs-comment">// 找出到根节点距离最大的节点</span>
                {
                    maxd = arr[t].depth;
                    maxdi = t;
                }
            }
        }
    }
    swap(arr[<span class="hljs-number">0</span>].edges[<span class="hljs-number">0</span>], arr[<span class="hljs-number">0</span>].edges[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 两次魔法操作（其实是把根节点的两条边换到前面去）</span>
    swap(arr[<span class="hljs-number">0</span>].edges[<span class="hljs-number">1</span>], arr[<span class="hljs-number">0</span>].edges[<span class="hljs-number">2</span>]);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">2</span> * (n - <span class="hljs-number">1</span>) - dfs(maxdi, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);
    <span class="hljs-comment">// 以第一次找到的节点为根节点遍历，找到距离最大的节点；</span>
    <span class="hljs-comment">// 2 (n - 1) - 直径长度即为最短距离</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>

    </body>
    </html>